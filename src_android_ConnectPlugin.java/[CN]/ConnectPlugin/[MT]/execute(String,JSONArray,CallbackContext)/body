{
  if (action.equals("init")) {
    Log.d(TAG,"init: Initializing plugin.");
    applicationId=args.getString(0);
    Session session=new Session.Builder(cordova.getActivity()).setApplicationId(applicationId).build();
    if (session.getState() == SessionState.CREATED_TOKEN_LOADED) {
      Session.setActiveSession(session);
      Session.OpenRequest openRequest=new Session.OpenRequest(cordova.getActivity());
      openRequest.setCallback(new Session.StatusCallback(){
        @Override public void call(        Session session,        SessionState state,        Exception exception){
          onSessionStateChange(state,exception,callbackContext);
        }
      }
);
      session.openForRead(openRequest);
    }
    if (session != null && session.isOpened()) {
      onSessionStateChange(session.getState(),null,callbackContext);
    }
    return true;
  }
 else   if (action.equals("login")) {
    String[] arrayPermissions=new String[args.length()];
    for (int i=0; i < args.length(); i++) {
      arrayPermissions[i]=args.getString(i);
    }
    List<String> permissions=null;
    if (arrayPermissions.length > 0) {
      permissions=Arrays.asList(arrayPermissions);
    }
    Session session=Session.getActiveSession();
    if (session != null && session.isOpened()) {
      boolean publishPermissions=false;
      boolean readPermissions=false;
      if (permissions == null) {
        readPermissions=true;
      }
      for (      String permission : arrayPermissions) {
        if (isPublishPermission(permission)) {
          publishPermissions=true;
        }
 else {
          readPermissions=true;
        }
        if (publishPermissions && readPermissions) {
          break;
        }
      }
      if (publishPermissions && readPermissions) {
        callbackContext.error("Cannot ask for both read and publish permissions.");
      }
 else {
        Session.NewPermissionsRequest newPermissionsRequest=new Session.NewPermissionsRequest(cordova.getActivity(),permissions);
        cordova.setActivityResultCallback(this);
        if (publishPermissions) {
          session.requestNewPublishPermissions(newPermissionsRequest);
        }
 else {
          session.requestNewReadPermissions(newPermissionsRequest);
        }
      }
    }
 else {
      session=new Session.Builder(cordova.getActivity()).setApplicationId(applicationId).build();
      Session.setActiveSession(session);
      Session.OpenRequest openRequest=new Session.OpenRequest(cordova.getActivity());
      openRequest.setPermissions(permissions);
      openRequest.setCallback(new Session.StatusCallback(){
        @Override public void call(        Session session,        SessionState state,        Exception exception){
          onSessionStateChange(state,exception,callbackContext);
        }
      }
);
      cordova.setActivityResultCallback(this);
      session.openForRead(openRequest);
    }
    return true;
  }
 else   if (action.equals("logout")) {
    Session session=Session.getActiveSession();
    if (session != null) {
      if (session.isOpened()) {
        session.closeAndClearTokenInformation();
        userId=null;
        callbackContext.success(getResponse());
      }
 else {
        callbackContext.error("Session not open.");
      }
    }
 else {
      callbackContext.error("No valid session found, must call init and login before logout.");
    }
    return true;
  }
 else   if (action.equals("getLoginStatus")) {
    callbackContext.success(getResponse());
    return true;
  }
 else   if (action.equals("showDialog")) {
    Bundle collect=new Bundle();
    JSONObject params=null;
    try {
      params=args.getJSONObject(0);
    }
 catch (    JSONException e) {
      params=new JSONObject();
    }
    final ConnectPlugin me=this;
    Iterator<?> iter=params.keys();
    while (iter.hasNext()) {
      String key=(String)iter.next();
      if (key.equals("method")) {
        try {
          this.method=params.getString(key);
        }
 catch (        JSONException e) {
          Log.w(TAG,"Nonstring method parameter provided to dialog");
        }
      }
 else {
        try {
          collect.putString(key,params.getString(key));
        }
 catch (        JSONException e) {
          Log.w(TAG,"Nonstring parameter provided to dialog discarded");
        }
      }
    }
    this.paramBundle=new Bundle(collect);
    if (this.method.equals(FEED_DIALOG)) {
      Runnable runnable=new Runnable(){
        public void run(){
          WebDialog feedDialog=(new WebDialog.FeedDialogBuilder(me.cordova.getActivity(),Session.getActiveSession(),paramBundle)).setOnCompleteListener(new UIDialogListener(callbackContext)).build();
          feedDialog.show();
        }
      }
;
      cordova.getActivity().runOnUiThread(runnable);
    }
 else     if (this.method.equals(APPREQUESTS_DIALOG)) {
      Runnable runnable=new Runnable(){
        public void run(){
          WebDialog requestsDialog=(new WebDialog.RequestsDialogBuilder(me.cordova.getActivity(),Session.getActiveSession(),paramBundle)).setOnCompleteListener(new UIDialogListener(callbackContext)).build();
          requestsDialog.show();
        }
      }
;
      cordova.getActivity().runOnUiThread(runnable);
    }
 else {
      callbackContext.error("Unsupported dialog method.");
    }
    return true;
  }
  return false;
}
